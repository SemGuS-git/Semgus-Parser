; Lisp-style comments only

(metadata :format-version "1.0.0") ; Optional
(metadata :author "Jinwoo Kim")
(metadata :realizable true)

(declare-term-type E.Term) ; <nt>.Term naming convention is optional
(declare-term-type B.Term)
; We could also write (declare-term-type (E.Term B.Term)) for brevity

(synth-term max2 E.Term (
  (declare-var (et et1 et2) E.Term) ; Invisible outside of synth-term
  (declare-var (bt bt1 bt2) B.Term)

  (declare-var (x y r r1 r2) Int) ; Var names cannot start with numerals
  (declare-var rb Bool)

  ; Declarations for nonterminals, including sem rel signature
  ; <nt>.Sem naming convention is optional
  (declare-nt IntExpr E.Term (IntExpr.Sem E.Term Int Int Int))
  (declare-nt B B.Term (B.Sem B.Term Int Int Bool))

  ; We can define multiple NTs per term type
  (declare-nt IntVar E.Term (IntVar.Sem E.Term Int Int Int))

  ((IntExpr et) (IntExpr.Sem et x y (! r :out)) ; Annotation used to mark output variable
    (x.Syn (= r x)) ; As usual, <node>.Syn naming convention is optional
    (y.Syn (= r y))
    (0.Syn (= r 0)) ; RHS constructors can start with numerals (SMTLIB2 does not allow this)

    ((+.Syn (IntExpr et1) (IntVar et2)) (and
      (IntExpr.Sem et1 x y r1)
      (IntVar.Sem et2 x y r2)
      (= r (+ r1 r2))
    ))

    ; Branching ITE
    ((ITE.Syn (B bt1) (IntVar et1) (IntVar et2))
      (and
        (B.Sem bt1 x y rb)
        (= rb true)
        (IntVar.Sem et1 x y r)
      )
      (and
        (B.Sem bt1 x y rb)
        (= rb false)
        (IntVar.Sem et2 x y r)
      )
    )
  )

  ; A different int expression NT that only produces leaf nodes
  ((IntVar et) (IntVar.Sem et x y (! r :out))
    (x.Syn (= r x))
    (y.Syn (= r y))
    (0.Syn (= r 0))
  )

  ((B bt) (B.Sem bt x y (! rb :out))

     (True.Syn (= rb true))
     (False.Syn (= rb false))

     ; Non-deterministic semantics: may or may not be supported by solvers
     (ND.Syn (= rb true) (= rb false))


  )
))

; Example-guided constraint
(constraint (and (IntExpr.Sem max2 4 2 4) (IntExpr.Sem max2 2 5 5)))

(declare-var (z w) Int) ; Could also be separate statements

; Universally quantified constraint
(constraint (=> (IntExpr.Sem max2 z (- z 1) w) (= w z)))
